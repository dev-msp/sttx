/// Collection of vendor-specific utilities
use std::collections::VecDeque;

use std::io::{self, BufRead};

pub struct BadCsvReader<R> {
    inner: io::BufReader<R>,
}

impl<'a, R: io::Read + 'a> BadCsvReader<R> {
    pub fn new(inner: R) -> Self {
        Self {
            inner: io::BufReader::new(inner),
        }
    }

    pub fn into_csv_reader(self) -> csv::Reader<Box<dyn io::Read + 'a>> {
        csv::ReaderBuilder::new()
            .escape(Some(b'\\'))
            .from_reader(Box::new(self))
    }
}

/// Removes quotes from lines that have exactly two commas (in other words, lines without commas
/// needing escaping)
///
/// Specifically intended to handle poorly-formatted CSV content generated by whisper.cpp.
impl<R: io::Read> io::Read for BadCsvReader<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        let mut line = String::new();
        let n = self.inner.read_line(&mut line)?;
        if n == 0 {
            return Ok(0);
        }
        let line_to_write = escape_nested_quotes(&line);

        let len = line_to_write.len();
        buf[..len].copy_from_slice(line_to_write.as_bytes());
        Ok(len)
    }
}

fn char_offsets(s: &str) -> impl Iterator<Item = (usize, char)> + '_ {
    s.chars().scan(0, |n, c| {
        let old_n = *n;
        *n = old_n + c.len_utf8();
        Some((old_n, c))
    })
}

fn escape_nested_quotes(line: &str) -> String {
    let offsets = {
        let mut bo = char_offsets(line)
            .filter_map(|(offset, c)| (c == '"').then_some(offset))
            .collect::<VecDeque<_>>();

        if bo.len() != 2 {
            bo.pop_front().zip(bo.pop_back())
        } else {
            None
        }
    };

    let Some((left, right)) = offsets else {
        return line.to_owned();
    };

    let mut new_line = String::new();
    new_line.push_str(&line[..left + 1]);
    new_line.push_str(&line[left + 1..right].replace('"', "\\\""));
    new_line.push_str(&line[right..]);

    new_line
}
